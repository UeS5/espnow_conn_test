#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/queue.h>
#include <freertos/event_groups.h>

#include <esp_timer.h>
#include <esp_twai.h>
#include <esp_twai_onchip.h>
#include <esp_wifi.h>
#include <esp_now.h>
#include <esp_event.h>
#include <esp_netif.h>
#include <nvs_flash.h>
#include <esp_log.h>
#include <esp_system.h>

#define STATUS_ESP_NOW              (1 << 0)
#define STATUS_ESP_NOW_CONN         (1 << 1)

EventGroupHandle_t STATUS_REG; 

TaskHandle_t vTask_register_mac_hdl;
TaskHandle_t vTask_pairing_hld; 
TaskHandle_t vTask_send_data_hld;

QueueHandle_t queue_esp_now_recv;

static const char *TAG_TASK_MANAGER = "TASK MANAGER"; 
static const char *TAG_TWAI = "TWAI";
static const char *TAG_ESP_NOW = "ESPNOW"; 
static const char *TAG_DECODER = "DECODER"; 

typedef struct {
	uint8_t tag;
	uint8_t data;
} esp_now_data_packet; 

// takes the MAC Addr and sends it to task register. 
void esp_now_recv_cb(const esp_now_recv_info_t *esp_now_info, const uint8_t *data, int len) {
	
	if (!esp_now_info || !data || len <= 0) {
		return; 
	}
	
	// send mac to the mac register task. 
	uint8_t mac[ESP_NOW_ETH_ALEN] = {0};
	memcpy(&mac, esp_now_info->src_addr, ESP_NOW_ETH_ALEN);

	xQueueSendFromISR(queue_esp_now_recv, mac, pdFALSE);   
		
} 



void vTask_start_esp_now(void *pvParameters) {

    ESP_LOGW(TAG_ESP_NOW, "Starting ESP-NOW...")
	esp_err_t ret = nvs_flash_init();  
	ESP_ERROR_CHECK(ret); 								  
	ESP_ERROR_CHECK(esp_netif_init());
	ESP_ERROR_CHECK(esp_event_loop_create_default());
	wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); 				 
	ESP_ERROR_CHECK(esp_wifi_init(&cfg));
	ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
	ESP_ERROR_CHECK(esp_wifi_start());
	esp_err_t init = esp_now_init();
    esp_err_t err = esp_now_register_recv_cb(esp_now_recv_cb); 
    
    vTaskDelay(pdMS_TO_TICKS(50))

    if (err != ESP_OK) {
        ESP_LOGE(TAG_ESP_NOW, "ESP-NOW callback could not be registered...");
        return; 
    }
    
    if (init != ESP_OK) {
         ESP_LOGE(TAG_ESP_NOW, "ESP-NOW could not be initialised...");
         return;
    }
    
    xEventGroupSetBits(STATUS_REG, STATUS_ESP_NOW)

	vTaskDelete(NULL); 
}

 

// queue_esp_now_recv den gelen mac adreslerini peer olarak ekliyor. 
void vTask_register_mac (void *args) {
	uint8_t mac[ESP_NOW_ETH_ALEN] = {0}; 
	esp_now_peer_info_t newPeer = {0};
	newPeer.ifidx =WIFI_IF_STA;
    newPeer.channel = 0;
	newPeer.encrypt	= false;
	
	ulTaskNotifyTake(pdTRUE, portMAX_DELAY); 
    for (;;) {

        if (xQueueReceive(queue_esp_now_recv, mac, portMAX_DELAY) == pdPASS) {

            esp_err_t err = esp_now_add_peer(&newPeer);

            if (err == ESP_OK) {

                ESP_LOGW(TAG_ESP_NOW, "A new global address has been added: %02X %02X %02X %02X %02X %02X", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
                xEventGroupSetBits(STATUS_REG, STATUS_ESP_NOW_CONN);
                memcpy(mac, global_peer_addr, ESP_NOW_ETH_ALEN);
                ulTaskNotifyGive(vTask_pairing_hdl);	
                
            } else if (err == ESP_ERR_ESPNOW_EXIST) {
                ESP_LOGE(TAG_ESP_NOW, "This peer already exists: %02X %02X %02X %02X %02X %02X", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
		    } else {
			    ESP_LOGE(TAG_ESP_NOW, "An error occured while adding the a new peer..");
		    }
	    }

	vTaskDelete(NULL); 

    }	 
}



// esp_now aktiflestirildikten hemen sonra basliyor. amaci broadcast yapip herhangi bir mac adresi almak. ack sinyali geldigi an durur. yerini check conna birakir. 
void vTask_pairing(void *pvParameters) {
	uint8_t broadcast_addr[ESP_NOW_ETH_ALEN] = BROADCAST_MAC;
	esp_now_peer_info_t broadcast = {0};
	memcpy(broadcast.peer_addr, broadcast_addr, ESP_NOW_ETH_ALEN);
	broadcast.ifidx = WIFI_IF_STA;
	broadcast.channel = 0;
	broadcast.encrypt = false;

	ulTaskNotifyTake(pdTRUE, portMAX_DELAY); 

	esp_err_t err_peer = esp_now_add_peer(&broadcast);
    
    if (err_peer != ESP_OK) {
        ESP_LOGE(TAG_ESP_NOW, "Could not add the broadcast peer. Returning from the task.");
        return;
    }
    
	esp_now_data_packet broadcast = {
        .tag = 31;
        .data = 0; 
    };

	for (;;) {

		(void)esp_now_send(broadcast_addr, (const uint8_t *)&broadcast, sizeof(broadcast));

        ESP_LOGW(TAG_ESP_NOW, "SENT BROADCAST")
			
		if (xEventGroupGetBits(STATUS_REG) & STATUS_ESP_NOW_CONN) { 
            ESP_LOGW(TAG_ESP_NOW, "EXITING PAIRING PROCESS..."); 
            break;
        }  
			
		vTaskDelay(pdMS_TO_TICKS(500));	
	}		

	vTaskDelete(NULL); 
}


int randomint

// queue_esp_now dan paketleri alip global_peer_addr ye yollar. 
void vTask_esp_now_send_data(void *args) {
    uint8_t randint = 0; 
	esp_now_data_packet pkt = 0; 
	esp_now_peer_info_t peer = 0;
	peer.ifidx = WIFI_IF_STA;
    peer.channel = 0;
	peer.encrypt = false;	
	
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY); 
    ESP_LOGW(TAG_ESP_NOW, "vTask_esp_now_send_data is triggerred!"); 

    for (;;) {
        
        if (memcmp(global_peer_addr, "\0\0\0\0\0\0", ESP_NOW_ETH_ALEN) == 0) {
            ESP_LOGE(TAG_ESP_NOW, "Global_peer_addr is EMPTY."); 
            continue;
        }

        memcpy(peer.peer_addr, global_peer_addr, ESP_NOW_ETH_ALEN);
        randint = esp_random() & 0xFF;
        pkt.tag = 1; 
        pkt.data = randint; 

        esp_now_send(peer.peer_addr, (uint8_t *)&pkt, sizeof(pkt)); 

        vTaskDelay(pdMS_TO_TICKS(200));
    }
}




void app_main(void)
{
    printf("Start of main"); 
    xTaskCreate(vTask_start_esp_now, "ESP-NOW Start", 4096, NULL, 1, NULL);
    xTaskCreate(vTask_register_mac, "Register MAC", 4096, NULL, 1, vTask_register_mac_hdl);
    xTaskCreate(vTask_pairing, "Pairing", 4096, NULL, 1, vTask_register_mac_hdl);

    while (xEventGroupGetBits(STATUS_REG) & STATUS_ESP_NOW == 0) {
        ESP_LOGW(TAG_ESP_NOW, "WAITING FOR ESP-NOW TO START...");
        vTaskDelay(pdMS_TO_TICKS(500)); 
    }

    ESP_LOGW(TAG_ESP_NOW, "STARTING PAIRING MODE AND REGISTER MAC TASK...");
    ulTaskNotify(vTask_pairing_hld);
    ulTaskNotify(vTask_register_mac_hdl);

    while 


}
